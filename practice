üîπ Lab 09 ‚Äì Introduction to POSIX Threads (pthreads)
1Ô∏è‚É£ Thread Creation & Join
#include <stdio.h>
#include <pthread.h>

void* thread_func(void* arg) {
    printf("Hello from thread\n");
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&t, NULL, thread_func, NULL);
    pthread_join(t, NULL);
    return 0;
}

2Ô∏è‚É£ Global Variable Shared Between Threads
#include <stdio.h>
#include <pthread.h>

int counter = 0;

void* increment(void* arg) {
    counter++;
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Counter: %d\n", counter);
    return 0;
}

3Ô∏è‚É£ Local Variable in Thread
#include <stdio.h>
#include <pthread.h>

void* func(void* arg) {
    int x = 5;
    printf("Local value: %d\n", x);
    return NULL;
}

int main() {
    pthread_t t;
    pthread_create(&t, NULL, func, NULL);
    pthread_join(t, NULL);
    return 0;
}

üîπ Lab 10 ‚Äì Thread Synchronization & Mutex
4Ô∏è‚É£ Race Condition (Without Mutex)
#include <stdio.h>
#include <pthread.h>

int count = 0;

void* add(void* arg) {
    for(int i = 0; i < 100000; i++)
        count++;
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, add, NULL);
    pthread_create(&t2, NULL, add, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Count: %d\n", count);
    return 0;
}

5Ô∏è‚É£ Mutex to Fix Race Condition
#include <stdio.h>
#include <pthread.h>

int count = 0;
pthread_mutex_t lock;

void* add(void* arg) {
    for(int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&lock);
        count++;
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lock, NULL);
    pthread_create(&t1, NULL, add, NULL);
    pthread_create(&t2, NULL, add, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Count: %d\n", count);
    pthread_mutex_destroy(&lock);
    return 0;
}

üîπ Lab 11 ‚Äì Thread Synchronization (Condition Variables & Barriers)
6Ô∏è‚É£ Condition Variable
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t lock;
pthread_cond_t cond;
int ready = 0;

void* worker(void* arg) {
    pthread_mutex_lock(&lock);
    while (!ready)
        pthread_cond_wait(&cond, &lock);
    printf("Thread proceeding\n");
    pthread_mutex_unlock(&lock);
    return NULL;
}

int main() {
    pthread_t t;
    pthread_mutex_init(&lock, NULL);
    pthread_cond_init(&cond, NULL);
    pthread_create(&t, NULL, worker, NULL);

    pthread_mutex_lock(&lock);
    ready = 1;
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&lock);

    pthread_join(t, NULL);
    return 0;
}

7Ô∏è‚É£ Barrier Synchronization
#include <stdio.h>
#include <pthread.h>

pthread_barrier_t barrier;

void* task(void* arg) {
    printf("Thread reached barrier\n");
    pthread_barrier_wait(&barrier);
    printf("Thread passed barrier\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_barrier_init(&barrier, NULL, 2);

    pthread_create(&t1, NULL, task, NULL);
    pthread_create(&t2, NULL, task, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_barrier_destroy(&barrier);
    return 0;
}
Race condition solved using mutex
#include <pthread.h>
#include <stdio.h>

int count = 0;
pthread_mutex_t m;

void* inc(void* arg) {
    pthread_mutex_lock(&m);
    count++;
    pthread_mutex_unlock(&m);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&m, NULL);

    pthread_create(&t1, NULL, inc, NULL);
    pthread_create(&t2, NULL, inc, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("%d\n", count);
    pthread_mutex_destroy(&m);
    return 0;
}

‚úÖ Lab 11 ‚Äì Condition Variable
Thread waits until condition is true
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t m;
pthread_cond_t c;
int ready = 0;

void* worker(void* arg) {
    pthread_mutex_lock(&m);
    while (!ready)
        pthread_cond_wait(&c, &m);
    printf("Thread resumed\n");
    pthread_mutex_unlock(&m);
    return NULL;
}

int main() {
    pthread_t t;
    pthread_mutex_init(&m, NULL);
    pthread_cond_init(&c, NULL);

    pthread_create(&t, NULL, worker, NULL);

    pthread_mutex_lock(&m);
    ready = 1;
    pthread_cond_signal(&c);
    pthread_mutex_unlock(&m);

    pthread_join(t, NULL);
    return 0;
}

‚úÖ Lab 11 ‚Äì Barrier (Very common MCQ/Viva)
#include <pthread.h>
#include <stdio.h>

pthread_barrier_t b;

void* task(void* arg) {
    printf("Before barrier\n");
    pthread_barrier_wait(&b);
    printf("After barrier\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_barrier_init(&b, NULL, 2);

    pthread_create(&t1, NULL, task, NULL);
    pthread_create(&t2, NULL, task, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
üîπ LAB 07 ‚Äî Process Management System Calls
1Ô∏è‚É£ Get Process ID & Parent Process ID
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("PID: %d\n", getpid());
    printf("PPID: %d\n", getppid());
    return 0;
}

2Ô∏è‚É£ fork() ‚Äì Parent & Child Identification
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0)
        printf("Child Process\n");
    else
        printf("Parent Process\n");

    return 0;
}

3Ô∏è‚É£ fork() with PID Values
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0)
        printf("Child PID: %d\n", getpid());
    else
        printf("Parent PID: %d\n", getpid());

    return 0;
}

4Ô∏è‚É£ Parent Waiting for Child (wait)
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0)
        printf("Child running\n");
    else {
        wait(NULL);
        printf("Parent finished waiting\n");
    }
    return 0;
}

5Ô∏è‚É£ waitpid()
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0)
        printf("Child\n");
    else {
        waitpid(pid, NULL, 0);
        printf("Parent after waitpid\n");
    }
    return 0;
}

üîπ LAB 08 ‚Äî Process Management (exec + Zombie + Orphan)
6Ô∏è‚É£ execvp()
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"ls", "-l", NULL};
    execvp("ls", args);
    return 0;
}

7Ô∏è‚É£ execv()
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"/bin/ls", "-l", NULL};
    execv("/bin/ls", args);
    return 0;
}

8Ô∏è‚É£ execl()
#include <stdio.h>
#include <unistd.h>

int main() {
    execl("/bin/ls", "ls", "-l", NULL);
    return 0;
}

9Ô∏è‚É£ execlp()
#include <stdio.h>
#include <unistd.h>

int main() {
    execlp("ls", "ls", "-l", NULL);
    return 0;
}

üîü fork + exec (MOST IMPORTANT)
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0)
        execlp("ls", "ls", NULL);
    else
        printf("Parent continues\n");

    return 0;
}

1Ô∏è‚É£1Ô∏è‚É£ Zombie Process
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0)
        printf("Child exits\n");
    else {
        sleep(20);
        printf("Parent sleeping\n");
    }
    return 0;
}

1Ô∏è‚É£2Ô∏è‚É£ Orphan Process
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        sleep(5);
        printf("Child, new PPID: %d\n", getppid());
    } else
        printf("Parent exits\n");

    return 0;
