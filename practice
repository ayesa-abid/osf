âœ… Task 1: Hello World with Threads + Timing
#include <stdio.h>
#include <omp.h>
#include <time.h>

int main() {
    clock_t start = clock();

    #pragma omp parallel
    {
        int id = omp_get_thread_num();
        int total = omp_get_num_threads();
        printf("Hello from thread %d of %d\n", id, total);
    }

    clock_t end = clock();
    printf("Time: %f seconds\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}


Run:

gcc task1.c -fopenmp -o task1
export OMP_NUM_THREADS=2 && ./task1
export OMP_NUM_THREADS=4 && ./task1
export OMP_NUM_THREADS=8 && ./task1

âœ… Task 2: Array Summation WITHOUT Work-Sharing (Duplicated Work)
#include <stdio.h>
#include <omp.h>
#include <time.h>

#define N 100000

int main() {
    int A[N], B[N], C[N];
    for (int i = 0; i < N; i++) {
        A[i] = i;
        B[i] = i;
    }

    clock_t start = clock();

    #pragma omp parallel
    {
        for (int i = 0; i < N; i++)
            C[i] = A[i] + B[i];
    }

    clock_t end = clock();
    printf("Time: %f seconds\n", (double)(end - start) / CLOCKS_PER_SEC);
    return 0;
}

âœ… Task 3: Array Summation WITH Work-Sharing (omp for)
#include <stdio.h>
#include <omp.h>
#include <time.h>

#define N 100000

int main() {
    int A[N], B[N], C[N];
    for (int i = 0; i < N; i++) {
        A[i] = i;
        B[i] = i;
    }

    clock_t seq_start = clock();
    for (int i = 0; i < N; i++)
        C[i] = A[i] + B[i];
    clock_t seq_end = clock();

    double par_start = omp_get_wtime();

    #pragma omp parallel for
    for (int i = 0; i < N; i++) {
        int id = omp_get_thread_num();
        printf("Thread %d computes index %d\n", id, i);
        C[i] = A[i] + B[i];
    }

    double par_end = omp_get_wtime();

    printf("Sequential Time: %f\n", (double)(seq_end - seq_start) / CLOCKS_PER_SEC);
    printf("Parallel Time: %f\n", par_end - par_start);
    return 0;
}

âœ… Task 4: Reduction â€“ Sum from 1 to 1,000,000
#include <stdio.h>
#include <omp.h>
#include <time.h>

#define N 1000000

int main() {
    long long sum = 0;

    clock_t s1 = clock();
    for (int i = 1; i <= N; i++)
        sum += i;
    clock_t e1 = clock();

    long long psum = 0;
    double s2 = omp_get_wtime();

    #pragma omp parallel for reduction(+:psum)
    for (int i = 1; i <= N; i++)
        psum += i;

    double e2 = omp_get_wtime();

    printf("Sequential Sum: %lld Time: %f\n", sum,
           (double)(e1 - s1) / CLOCKS_PER_SEC);
    printf("Parallel Sum: %lld Time: %f\n", psum, e2 - s2);
    return 0;
}

âœ… Task 5: Sections â€“ Independent Work
#include <stdio.h>
#include <omp.h>
#include <time.h>

#define N 100000

int main() {
    int A[N], B[N], C[N];
    for (int i = 0; i < N; i++) {
        A[i] = i + 1;
        B[i] = 2;
        C[i] = i;
    }

    clock_t s1 = clock();
    long long sum = 0, prod = 1;
    int max = C[0];

    for (int i = 0; i < N; i++) sum += A[i];
    for (int i = 0; i < N; i++) prod *= B[i];
    for (int i = 0; i < N; i++) if (C[i] > max) max = C[i];

    clock_t e1 = clock();

    double s2 = omp_get_wtime();

    #pragma omp parallel sections
    {
        #pragma omp section
        {
            long long s = 0;
            for (int i = 0; i < N; i++) s += A[i];
            printf("Sum = %lld\n", s);
        }

        #pragma omp section
        {
            long long p = 1;
            for (int i = 0; i < N; i++) p *= B[i];
            printf("Product = %lld\n", p);
        }

        #pragma omp section
        {
            int m = C[0];
            for (int i = 0; i < N; i++) if (C[i] > m) m = C[i];
            printf("Max = %d\n", m);
        }
    }

    double e2 = omp_get_wtime();

    printf("Sequential Time: %f\n", (double)(e1 - s1) / CLOCKS_PER_SEC);
    printf("Parallel Time: %f\n", e2 - s2);
    return 0;
}

ðŸ”‘ Compile (same for all)
gcc filename.c -fopenmp -o filename

ðŸ”‘ Run with threads
export OMP_NUM_THREADS=2
./filename

export OMP_NUM_THREADS=4
./filename

export OMP_NUM_THREADS=8
./filename
âœ… Task 1 â€“ Hello World with critical
#include <stdio.h>
#include <omp.h>

int main() {

    #pragma omp parallel num_threads(4)
    {
        int id = omp_get_thread_num();
        int total = omp_get_num_threads();

        #pragma omp critical
        {
            printf("Hello from thread %d of %d\n", id, total);
        }
    }

    return 0;
}

âœ… Task 2 â€“ Vector Sum with Reduction
#include <stdio.h>
#include <omp.h>

#define N 1000000

int main() {
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = 1;

    int seq_sum = 0;
    for (int i = 0; i < N; i++)
        seq_sum += arr[i];

    int par_sum = 0;
    #pragma omp parallel for reduction(+:par_sum)
    for (int i = 0; i < N; i++)
        par_sum += arr[i];

    printf("Sequential Sum: %d\n", seq_sum);
    printf("Parallel Sum: %d\n", par_sum);

    return 0;
}

âœ… Task 3 â€“ Min & Max of Array
#include <stdio.h>
#include <omp.h>

#define N 20

int main() {
    int arr[N] = {12, 5, 8, 19, 3, 7, 15, 2, 10, 6,
                  14, 9, 1, 18, 4, 11, 13, 17, 16, 20};

    int minVal = arr[0], maxVal = arr[0];

    #pragma omp parallel for reduction(min:minVal) reduction(max:maxVal)
    for (int i = 0; i < N; i++) {
        if (arr[i] < minVal) minVal = arr[i];
        if (arr[i] > maxVal) maxVal = arr[i];
    }

    printf("Min (Reduction): %d\n", minVal);
    printf("Max (Reduction): %d\n", maxVal);

    minVal = arr[0];
    maxVal = arr[0];

    #pragma omp parallel for
    for (int i = 0; i < N; i++) {
        #pragma omp critical
        {
            if (arr[i] < minVal) minVal = arr[i];
            if (arr[i] > maxVal) maxVal = arr[i];
        }
    }

    printf("Min (Critical): %d\n", minVal);
    printf("Max (Critical): %d\n", maxVal);

    return 0;
}

âœ… Task 4 â€“ Shared Counter with / without critical
#include <stdio.h>
#include <omp.h>

int main() {
    int counter = 0;

    #pragma omp parallel num_threads(8)
    {
        counter++;
    }
    printf("Without critical: %d\n", counter);

    counter = 0;

    #pragma omp parallel num_threads(8)
    {
        #pragma omp critical
        {
            counter++;
        }
    }
    printf("With critical: %d\n", counter);

    return 0;
}

âœ… Task 5 â€“ Matrix Multiplication with OpenMP
#include <stdio.h>
#include <omp.h>

#define N 200

int main() {
    static int A[N][N], B[N][N], C[N][N];

    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++) {
            A[i][j] = 1;
            B[i][j] = 1;
            C[i][j] = 0;
        }

    double start = omp_get_wtime();

    #pragma omp parallel for
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            int sum = 0;
            for (int k = 0; k < N; k++)
                sum += A[i][k] * B[k][j];
            C[i][j] = sum;
        }
    }

    double end = omp_get_wtime();
    printf("Parallel Matrix Multiplication Time: %f\n", end - start);

    return 0;
}

ðŸ”‘ Compile & Run
gcc file.c -fopenmp -o file
export OMP_NUM_THREADS=2
./file
export OMP_NUM_THREADS=4
./file
export OMP_NUM_THREADS=8
./file
âœ… Task 1 â€“ Private vs Shared Variable
#include <stdio.h>
#include <omp.h>

int main() {
    int x = 10;

    #pragma omp parallel private(x)
    {
        x = 5;
        printf("Private x in thread %d = %d\n",
               omp_get_thread_num(), x);
    }

    printf("After private region, x = %d\n", x);

    #pragma omp parallel shared(x)
    {
        #pragma omp atomic
        x++;
    }

    printf("After shared region, x = %d\n", x);
    return 0;
}

âœ… Task 2 â€“ Barrier Demonstration
#include <stdio.h>
#include <omp.h>

int main() {

    #pragma omp parallel num_threads(4)
    {
        int id = omp_get_thread_num();
        printf("Thread %d reached before barrier\n", id);

        #pragma omp barrier

        printf("Thread %d passed barrier\n", id);
    }

    return 0;
}

âœ… Task 3 â€“ Atomic Counter
#include <stdio.h>
#include <omp.h>

int main() {
    int counter = 0;

    #pragma omp parallel num_threads(16)
    {
        for (int i = 0; i < 100; i++)
            counter++;
    }
    printf("Without atomic: %d\n", counter);

    counter = 0;

    #pragma omp parallel num_threads(16)
    {
        for (int i = 0; i < 100; i++) {
            #pragma omp atomic
            counter++;
        }
    }
    printf("With atomic: %d\n", counter);

    return 0;
}

âœ… Task 4 â€“ Master Thread Logging
#include <stdio.h>
#include <omp.h>

int main() {

    #pragma omp parallel num_threads(8)
    {
        #pragma omp master
        printf("Master: Work started\n");

        printf("Thread %d doing work\n",
               omp_get_thread_num());

        #pragma omp master
        printf("Master: All work done\n");
    }

    return 0;
}

âœ… Task 5 â€“ Parallel Array Summation
#include <stdio.h>
#include <omp.h>

#define N 100

int main() {
    int arr[N], sum = 0;

    for (int i = 0; i < N; i++)
        arr[i] = i + 1;

    #pragma omp parallel for
    for (int i = 0; i < N; i++) {
        #pragma omp atomic
        sum += arr[i];
    }
    printf("Method A (Atomic) Sum = %d\n", sum);

    sum = 0;

    #pragma omp parallel
    {
        int local_sum = 0;

        #pragma omp for
        for (int i = 0; i < N; i++)
            local_sum += arr[i];

        printf("Thread %d partial sum = %d\n",
               omp_get_thread_num(), local_sum);

        #pragma omp atomic
        sum += local_sum;
    }

    printf("Method B (Private + Atomic) Sum = %d\n", sum);
    return 0;
}

ðŸ”‘ Compile & Run
gcc file.c -fopenmp -o file
export OMP_NUM_THREADS=4
./file
Task 1: Parallel Sorting with ordered Output
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

#define N 16
#define SEG 4

int cmp(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = rand() % 100;

    double start = omp_get_wtime();

    #pragma omp parallel for ordered num_threads(4)
    for (int i = 0; i < 4; i++) {
        qsort(&arr[i * SEG], SEG, sizeof(int), cmp);

        #pragma omp ordered
        {
            printf("Segment %d: ", i + 1);
            for (int j = 0; j < SEG; j++)
                printf("%d ", arr[i * SEG + j]);
            printf("\n");
        }
    }

    double end = omp_get_wtime();
    printf("Time: %f\n", end - start);
    return 0;
}


ðŸ”¹ Remove ordered to observe random segment printing order

âœ… Task 2: Matrix Multiplication (with & without ordered)
#include <stdio.h>
#include <omp.h>

#define N 4

int main() {
    int A[N][N], B[N][N], C[N][N];

    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++) {
            A[i][j] = 1;
            B[i][j] = 1;
            C[i][j] = 0;
        }

    double start1 = omp_get_wtime();

    #pragma omp parallel for
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++) {
            for (int k = 0; k < N; k++)
                C[i][j] += A[i][k] * B[k][j];
            printf("C[%d][%d] = %d\n", i, j, C[i][j]);
        }

    double end1 = omp_get_wtime();

    double start2 = omp_get_wtime();

    #pragma omp parallel for ordered
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++) {
            int sum = 0;
            for (int k = 0; k < N; k++)
                sum += A[i][k] * B[k][j];

            #pragma omp ordered
            printf("Ordered C[%d][%d] = %d\n", i, j, sum);
        }

    double end2 = omp_get_wtime();

    printf("Without ordered time: %f\n", end1 - start1);
    printf("With ordered time: %f\n", end2 - start2);

    return 0;
}

âœ… Task 3: Squares with Ordered Output
#include <stdio.h>
#include <omp.h>

int main() {

    double start1 = omp_get_wtime();

    #pragma omp parallel for
    for (int i = 1; i <= 20; i++) {
        int id = omp_get_thread_num();
        printf("Thread %d computed square of %d = %d\n", id, i, i * i);
    }

    double end1 = omp_get_wtime();

    double start2 = omp_get_wtime();

    #pragma omp parallel for ordered
    for (int i = 1; i <= 20; i++) {
        int id = omp_get_thread_num();
        #pragma omp ordered
        printf("Thread %d computed square of %d = %d\n", id, i, i * i);
    }

    double end2 = omp_get_wtime();

    printf("Without ordered time: %f\n", end1 - start1);
    printf("With ordered time: %f\n", end2 - start2);

    return 0;
}
